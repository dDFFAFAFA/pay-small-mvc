# 核心业务流程时序图

## 一、支付下单流程

### 流程图

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant Controller as AliPayController
    participant Service as OrderServiceImpl
    participant Dao as IOrderDao
    participant RPC as ProductRPC
    participant Alipay as 支付宝API

    Client->>Controller: POST /api/v1/alipay/create_pay_order<br/>{userId, productId}
    Controller->>Service: createOrder(ShopCartReq)
    
    Service->>Dao: queryUnPayOrder()<br/>查询未支付订单
    alt 存在未支付订单(PAY_WAIT)
        Dao-->>Service: 返回未支付订单
        Service-->>Controller: 返回已有支付URL
        Controller-->>Client: 返回支付链接
    else 存在创建状态订单(CREATE)
        Dao-->>Service: 返回创建状态订单
        Service->>Service: doPrepayOrder()<br/>创建支付单
        Service->>Alipay: 调用支付宝API创建支付
        Alipay-->>Service: 返回支付表单HTML
        Service->>Dao: updateOrderPayInfo()<br/>更新订单支付信息
        Service-->>Controller: 返回支付URL
        Controller-->>Client: 返回支付链接
    else 不存在订单
        Service->>RPC: queryProductByProductId()<br/>查询商品信息
        RPC-->>Service: 返回商品信息
        Service->>Dao: insert()<br/>创建订单(状态:CREATE)
        Service->>Service: doPrepayOrder()<br/>创建支付单
        Service->>Alipay: 调用支付宝API创建支付
        Alipay-->>Service: 返回支付表单HTML
        Service->>Dao: updateOrderPayInfo()<br/>更新订单状态为PAY_WAIT
        Service-->>Controller: 返回支付URL
        Controller-->>Client: 返回支付链接
    end
```

### 流程说明

1. **客户端请求**: 发送下单请求，包含用户ID和商品ID
2. **订单查询**: 检查是否存在未支付订单
   - 如果存在 `PAY_WAIT` 状态订单，直接返回已有支付链接
   - 如果存在 `CREATE` 状态订单，创建支付单
   - 如果不存在，创建新订单
3. **商品查询**: 通过 ProductRPC 获取商品信息
4. **订单创建**: 在数据库中插入订单记录（状态: `CREATE`）
5. **支付单创建**: 调用支付宝 API 生成支付表单
6. **订单更新**: 更新订单状态为 `PAY_WAIT`，保存支付链接
7. **返回结果**: 返回支付表单 HTML，客户端可直接跳转支付

---

## 二、支付回调流程

### 流程图

```mermaid
sequenceDiagram
    participant Alipay as 支付宝平台
    participant Controller as AliPayController
    participant Service as OrderServiceImpl
    participant Dao as IOrderDao
    participant EventBus as EventBus
    participant Listener as OrderPaySuccessListener

    Alipay->>Controller: POST /api/v1/alipay/alipay_notify_url<br/>支付回调通知
    
    Controller->>Controller: 验证回调参数<br/>trade_status = TRADE_SUCCESS
    
    Controller->>Controller: 组装回调参数Map
    
    Controller->>Controller: 验证支付宝签名<br/>AlipaySignature.rsa256CheckContent()
    
    alt 签名验证失败
        Controller-->>Alipay: 返回 "false"
    else 签名验证成功
        Controller->>Service: changeOrderPaySuccess(orderId)
        Service->>Dao: changeOrderPaySuccess()<br/>更新订单状态为PAY_SUCCESS<br/>记录支付时间
        
        Service->>EventBus: post() 发布支付成功事件
        
        EventBus->>Listener: handleEvent()<br/>支付成功消息
        
        Listener->>Listener: 处理后续业务<br/>（发货、充值、开户、返利等）
        
        Controller-->>Alipay: 返回 "success"
    end
```

### 流程说明

1. **支付回调**: 用户完成支付后，支付宝异步回调系统
2. **参数验证**: 验证回调参数中的交易状态
3. **签名验证**: 使用支付宝公钥验证回调签名，防止伪造
4. **订单更新**: 
   - 更新订单状态为 `PAY_SUCCESS`
   - 记录支付时间
5. **事件发布**: 通过 EventBus 发布支付成功事件
6. **后续处理**: 监听器处理后续业务（发货、充值等）
7. **响应支付宝**: 返回 "success" 表示处理成功

---

## 三、微信扫码登录流程

### 流程图

```mermaid
sequenceDiagram
    participant Client as 客户端
    participant LoginController as LoginController
    participant LoginService as WeixinLoginServiceImpl
    participant WeixinAPI as 微信API
    participant Cache as Guava Cache
    participant PortalController as WeixinPortalController

    Note over Client,PortalController: 第一步：生成二维码
    Client->>LoginController: GET /api/v1/login/weixin_qrcode_ticket
    LoginController->>LoginService: createQrCodeTicket()
    
    LoginService->>Cache: 获取 accessToken
    alt accessToken 不存在
        LoginService->>WeixinAPI: 调用微信API获取token
        WeixinAPI-->>LoginService: 返回 accessToken
        LoginService->>Cache: 缓存 accessToken
    end
    
    LoginService->>WeixinAPI: 创建二维码ticket
    WeixinAPI-->>LoginService: 返回 ticket
    LoginService-->>LoginController: 返回 ticket
    LoginController-->>Client: 返回 ticket
    
    Note over Client,PortalController: 第二步：用户扫码
    Client->>Client: 用户使用微信扫描二维码
    
    Note over Client,PortalController: 第三步：微信回调
    Client->>PortalController: POST /api/v1/weixin/portal/receive<br/>微信推送扫码事件
    PortalController->>PortalController: 验证微信签名
    
    PortalController->>LoginService: saveLoginState(ticket, openid)
    LoginService->>Cache: 保存 ticket -> openid 映射
    
    LoginService->>WeixinAPI: 发送模板消息通知用户
    WeixinAPI-->>LoginService: 发送成功
    
    PortalController-->>Client: 返回XML消息
    
    Note over Client,PortalController: 第四步：轮询检查登录状态
    loop 轮询检查
        Client->>LoginController: GET /api/v1/login/check_login?ticket=xxx
        LoginController->>LoginService: checkLogin(ticket)
        LoginService->>Cache: 查询 ticket 对应的 openid
        
        alt 找到 openid
            LoginService-->>LoginController: 返回 openidToken
            LoginController-->>Client: 返回 openidToken（登录成功）
        else 未找到
            LoginService-->>LoginController: 返回 null
            LoginController-->>Client: 返回未登录状态
        end
    end
```

### 流程说明

1. **生成二维码**: 
   - 客户端请求生成登录二维码
   - 系统调用微信 API 获取 accessToken（带缓存）
   - 调用微信 API 创建二维码，获取 ticket
   - 返回 ticket 给客户端

2. **用户扫码**: 用户使用微信扫描二维码

3. **微信回调**: 
   - 微信推送扫码事件到系统
   - 系统验证签名
   - 保存 ticket 与 openid 的映射关系（存入缓存）
   - 发送模板消息通知用户登录成功

4. **轮询检查**: 
   - 客户端轮询检查登录状态
   - 系统从缓存中查找 ticket 对应的 openid
   - 如果找到，返回 openidToken，登录成功

---

## 四、定时任务流程

### 4.1 超时关单任务

```mermaid
sequenceDiagram
    participant Scheduler as Spring Scheduler
    participant Job as TimeoutCloseOrderJob
    participant Service as OrderServiceImpl
    participant Dao as IOrderDao

    Note over Scheduler: 每10分钟执行一次<br/>@Scheduled(cron = "0 0/10 * * * ?")
    
    Scheduler->>Job: exec()
    Job->>Service: queryTimeoutCloseOrderList()
    Service->>Dao: 查询超时30分钟未支付订单<br/>WHERE status='PAY_WAIT'<br/>AND NOW() >= order_time + 30 MINUTE
    
    Dao-->>Service: 返回订单ID列表
    Service-->>Job: 返回订单ID列表
    
    loop 遍历每个订单
        Job->>Service: changeOrderClose(orderId)
        Service->>Dao: 更新订单状态为CLOSE
        Dao-->>Service: 更新成功
        Service-->>Job: 返回结果
    end
```

**功能**: 每10分钟检查一次，关闭超过30分钟未支付的订单

---

### 4.2 支付回调检测任务

```mermaid
sequenceDiagram
    participant Scheduler as Spring Scheduler
    participant Job as NoPayNotifyOrderJob
    participant Service as OrderServiceImpl
    participant Dao as IOrderDao
    participant Alipay as 支付宝API

    Note over Scheduler: 每3秒执行一次<br/>@Scheduled(cron = "0/3 * * * * ?")
    
    Scheduler->>Job: exec()
    Job->>Service: queryNoPayNotifyOrder()
    Service->>Dao: 查询超过1分钟未收到回调的订单<br/>WHERE status='PAY_WAIT'<br/>AND NOW() >= order_time + 1 MINUTE
    
    Dao-->>Service: 返回订单ID列表
    Service-->>Job: 返回订单ID列表
    
    loop 遍历每个订单
        Job->>Alipay: 调用支付宝查询接口<br/>alipay.trade.query()
        Alipay-->>Job: 返回订单状态
        
        alt 订单已支付(code=10000)
            Job->>Service: changeOrderPaySuccess(orderId)
            Service->>Dao: 更新订单状态为PAY_SUCCESS
        else 订单未支付
            Note over Job: 继续等待
        end
    end
```

**功能**: 每3秒检查一次，主动查询可能未收到回调的支付订单，确保订单状态同步

---

## 五、事件驱动流程

### 支付成功事件处理

```mermaid
sequenceDiagram
    participant Service as OrderServiceImpl
    participant EventBus as Guava EventBus
    participant Listener as OrderPaySuccessListener

    Service->>Service: changeOrderPaySuccess(orderId)
    Service->>EventBus: post(payOrderJSON)
    
    EventBus->>Listener: handleEvent(paySuccessMessage)
    
    Note over Listener: 处理后续业务逻辑：<br/>- 发货<br/>- 充值<br/>- 开户<br/>- 返利等
    
    Listener->>Listener: 执行业务处理
```

**功能**: 支付成功后，通过事件总线异步处理后续业务，解耦业务逻辑

---

## 六、订单状态流转

### 状态机图

```mermaid
stateDiagram-v2
    [*] --> CREATE: 创建订单
    CREATE --> PAY_WAIT: 创建支付单成功
    CREATE --> CREATE: 掉单重试
    PAY_WAIT --> PAY_SUCCESS: 支付成功(回调)
    PAY_WAIT --> CLOSE: 超时30分钟关闭
    PAY_WAIT --> PAY_SUCCESS: 主动查询发现已支付
    PAY_SUCCESS --> DEAL_DONE: 发货完成
    
    note right of CREATE
        订单已创建，等待创建支付单
    end note
    
    note right of PAY_WAIT
        等待用户支付
    end note
    
    note right of PAY_SUCCESS
        支付成功，等待发货
    end note
    
    note right of CLOSE
        订单已关闭，不可再支付
    end note
```

### 状态说明

- **CREATE**: 订单创建完成，等待创建支付单
- **PAY_WAIT**: 等待支付，已生成支付链接
- **PAY_SUCCESS**: 支付成功，等待发货
- **DEAL_DONE**: 交易完成，已发货
- **CLOSE**: 超时关闭，订单失效

