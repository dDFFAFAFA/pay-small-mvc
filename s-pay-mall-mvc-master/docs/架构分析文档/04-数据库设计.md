# 数据库表结构设计

## 一、数据库信息

- **数据库名**: `s-pay-mall`
- **字符集**: `utf8mb4`
- **排序规则**: `utf8mb4` 默认排序规则
- **存储引擎**: `InnoDB`

## 二、数据表设计

### 2.1 pay_order（支付订单表）

#### 表结构

| 字段名 | 类型 | 约束 | 说明 |
|--------|------|------|------|
| id | int unsigned | PRIMARY KEY, AUTO_INCREMENT | 自增主键 |
| user_id | varchar(32) | NOT NULL | 用户ID |
| product_id | varchar(16) | NOT NULL | 商品ID |
| product_name | varchar(64) | NOT NULL | 商品名称 |
| order_id | varchar(16) | NOT NULL, UNIQUE | 订单ID（16位随机数字） |
| order_time | datetime | NOT NULL | 下单时间 |
| total_amount | decimal(8,2) unsigned | NULL | 订单金额（最大999999.99） |
| status | varchar(32) | NOT NULL | 订单状态 |
| pay_url | varchar(2014) | NULL | 支付链接（支付宝返回的HTML表单） |
| pay_time | datetime | NULL | 支付时间 |
| create_time | datetime | NOT NULL, DEFAULT CURRENT_TIMESTAMP | 创建时间 |
| update_time | datetime | NOT NULL, DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP | 更新时间 |

#### 索引设计

```sql
PRIMARY KEY (`id`)                                    -- 主键索引
UNIQUE KEY `uq_order_id` (`order_id`)               -- 订单ID唯一索引
KEY `idx_user_id_product_id` (`user_id`,`product_id`) -- 用户商品复合索引
```

**索引说明**:
- **主键索引**: 用于快速定位单条记录
- **订单ID唯一索引**: 确保订单ID唯一，快速查询订单
- **用户商品复合索引**: 优化查询用户对某商品的未支付订单

#### 建表SQL

```sql
CREATE TABLE `pay_order` (
  `id` int unsigned NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `user_id` varchar(32) CHARACTER SET utf8mb4 NOT NULL COMMENT '用户ID',
  `product_id` varchar(16) NOT NULL COMMENT '商品ID',
  `product_name` varchar(64) NOT NULL COMMENT '商品名称',
  `order_id` varchar(16) CHARACTER SET utf8mb4 NOT NULL COMMENT '订单ID',
  `order_time` datetime NOT NULL COMMENT '下单时间',
  `total_amount` decimal(8,2) unsigned DEFAULT NULL COMMENT '订单金额',
  `status` varchar(32) CHARACTER SET utf8mb4 NOT NULL COMMENT '订单状态；create-创建完成、pay_wait-等待支付、pay_success-支付成功、deal_done-交易完成、close-订单关单',
  `pay_url` varchar(2014) CHARACTER SET utf8mb4 DEFAULT NULL COMMENT '支付信息',
  `pay_time` datetime DEFAULT NULL COMMENT '支付时间',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uq_order_id` (`order_id`),
  KEY `idx_user_id_product_id` (`user_id`,`product_id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8mb4;
```

---

## 三、订单状态枚举值

根据代码 `Constants.OrderStatusEnum` 定义：

| 状态码 | 状态名称 | 说明 |
|--------|----------|------|
| CREATE | 创建完成 | 订单已创建，等待创建支付单 |
| PAY_WAIT | 等待支付 | 支付单已创建，等待用户支付 |
| PAY_SUCCESS | 支付成功 | 已接收到支付回调，支付成功 |
| DEAL_DONE | 交易完成 | 商品发货完成 |
| CLOSE | 订单关闭 | 超时未支付，订单关闭 |

---

## 四、字段详细说明

### 4.1 核心业务字段

- **order_id**: 
  - 16位随机数字（通过 `RandomStringUtils.randomNumeric(16)` 生成）
  - 作为订单唯一标识，对应支付宝的 `out_trade_no`
  - 有唯一索引，防止重复

- **status**: 
  - 订单状态，遵循状态机流转
  - 用于查询未支付订单、超时订单等

- **pay_url**: 
  - 存储支付宝返回的 HTML 表单字符串
  - 长度最大 2014 字符（支付宝限制）
  - 客户端获取后可直接渲染跳转支付

### 4.2 时间字段

- **order_time**: 用户下单时间，用于计算超时
- **pay_time**: 支付成功时间，支付宝回调时更新
- **create_time**: 记录创建时间，自动填充
- **update_time**: 记录更新时间，自动更新

### 4.3 金额字段

- **total_amount**: 
  - 使用 `decimal(8,2)` 类型，确保精度
  - 最大金额：999999.99 元
  - unsigned 表示不允许负数

---

## 五、数据访问操作

### 5.1 插入操作

```sql
INSERT INTO pay_order(user_id, product_id, product_name, order_id, order_time,
        total_amount, status, create_time, update_time)
VALUES(#{userId}, #{productId}, #{productName}, #{orderId}, #{orderTime},
        #{totalAmount}, #{status}, now(), now())
```

**使用场景**: 创建新订单

### 5.2 查询操作

#### 查询未支付订单

```sql
SELECT product_id, product_name, order_id, order_time, total_amount, status, pay_url
FROM pay_order
WHERE user_id = #{userId} AND product_id = #{productId}
ORDER BY id DESC
LIMIT 1
```

**使用场景**: 创建订单前，检查是否存在未支付订单

#### 查询超时关闭订单列表

```sql
SELECT order_id as orderId FROM pay_order
WHERE status = 'PAY_WAIT' AND NOW() >= order_time + INTERVAL 30 MINUTE
ORDER BY id ASC
LIMIT 50
```

**使用场景**: 定时任务，查询超过30分钟未支付的订单

#### 查询未收到回调的订单

```sql
SELECT order_id as orderId FROM pay_order
WHERE status = 'PAY_WAIT' AND NOW() >= order_time + INTERVAL 1 MINUTE
ORDER BY id ASC
LIMIT 10
```

**使用场景**: 定时任务，主动查询可能未收到回调的订单

### 5.3 更新操作

#### 更新订单支付信息

```sql
UPDATE pay_order 
SET pay_url = #{payUrl}, status = #{status}, update_time = now()
WHERE order_id = #{orderId}
```

**使用场景**: 创建支付单后，更新支付链接和状态

#### 更新订单为支付成功

```sql
UPDATE pay_order 
SET status = #{status}, pay_time = now(), update_time = now()
WHERE order_id = #{orderId}
```

**使用场景**: 支付回调后，更新订单状态

#### 关闭订单

```sql
UPDATE pay_order 
SET status = 'CLOSE', pay_time = now(), update_time = now()
WHERE order_id = #{orderId}
```

**使用场景**: 超时关单任务

---

## 六、数据模型映射

### 6.1 实体类 PayOrder

```java
public class PayOrder {
    private Long id;                    // id
    private String userId;               // user_id
    private String productId;            // product_id
    private String productName;          // product_name
    private String orderId;              // order_id
    private Date orderTime;              // order_time
    private BigDecimal totalAmount;      // total_amount
    private String status;               // status
    private String payUrl;               // pay_url
    private Date payTime;                // pay_time
    private Date createTime;             // create_time
    private Date updateTime;             // update_time
}
```

### 6.2 MyBatis 映射

参见 `pay_order_mapper.xml`:
- 使用 `resultMap` 映射字段
- 驼峰命名自动转换
- 时间字段映射为 `Date` 类型

---

## 七、数据一致性保障

### 7.1 唯一性约束

- `order_id` 唯一索引：确保订单ID不重复
- 业务层面：创建订单前检查是否存在未支付订单

### 7.2 状态一致性

- 通过状态枚举确保状态值规范
- 定时任务主动查询，补偿未收到的回调
- 超时关单机制，防止订单长期处于待支付状态

### 7.3 时间字段

- `create_time` 和 `update_time` 使用数据库默认值，确保准确性
- `order_time` 由应用层控制，用于业务计算
- `pay_time` 在支付回调时更新

---

## 八、性能优化建议

### 8.1 索引优化

- **已优化**: 用户商品复合索引，支持快速查询未支付订单
- **建议**: 如果查询 `status` 字段频繁，可考虑添加 `status` 索引

### 8.2 查询优化

- 使用 `LIMIT` 限制查询结果数量（定时任务）
- 使用 `ORDER BY id DESC` 查询最新订单
- 复合索引覆盖查询，减少回表

### 8.3 分表建议

- 如果订单量巨大，可按时间或用户ID分表
- 历史订单可归档到历史表

---

## 九、扩展性设计

### 9.1 字段扩展

表结构预留了扩展空间：
- `status` 字段支持更多状态值
- 可添加扩展字段存储额外信息（如退款信息、物流信息等）

### 9.2 业务扩展

- 支持多商品订单：可考虑拆分订单表，增加订单明细表
- 支持优惠券：可添加优惠金额字段
- 支持退款：可添加退款状态和金额字段

